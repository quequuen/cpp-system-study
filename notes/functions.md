## functions

### 매개변수 vs 실인자 (Parameter vs Argument)

- 매개변수(Parameter): 함수 정의부에 있는 변수, 어떤 데이터를 받을지 선언하는 틀.
- 실인자(Argument): 함수를 호출할 때 실제로 전달하는 값.

### 데이터 전달 방식

데이터를 어떻게 복제하거나 연결하느냐의 차이

1. 값에 의한 전달(Call by Value)
   실인자의 값만 복사해서 매개변수에 전달.

- 메모리: 매개변수를 위한 새로운 메모리 공간이 할당, 값이 그대로 복사.
- 특징: 함수 안에서 아무리 값을 바꿔도 원본은 변하지 않음.(안전성)
- 단점: 데이터 덩어리가 클 경우, 복사하는 데 시간과 메모리가 낭비됨.

```cpp
void changeValue(int a) {
    a = 999; // 복사본만 수정됨
}

int main() {
    int x = 10;
    changeValue(x);
    // x는 여전히 10
}
```

2. 주소에 의한 전달(Call by Address)

실인자는 메모리 주소를 전달. 매개변수는 포인터 변수.

- 메모리: 주소값(일반적으로 8바이트)만 복사. 매개변수인 포인터는 원본의 주소를 가리킴.
- 특징: \* 연산자(역참조)를 통해 원본을 직접 수정 가능. nullptr을 넘길 수 있어 null 표현 가능.
- 단점: \*나 & 기호로 인해 가독성이 떨어지며 잘못된 주소를 건드릴 위험 존재.

```cpp
void changeAddress(int* ptr) {
    if (ptr != nullptr) {
        *ptr = 999; // 주소를 찾아가서 원본 수정
    }
}

int main() {
    int x = 10;
    changeAddress(&x); // 주소를 넘김
    // x는 이제 999
}
```

3. 참조에 의한 전달(Call by Reference)

실인자의 별명(Alias)를 전달. 매개변수가 원본과 이름을 공유.

- 메모리: 내부적으로는 주소를 넘기지만, 겉으로는 복사가 일어나지 않는 것처럼 보임. (포인터의 자동화)
- 특징: \* 기호 없이 일반 변수처럼 쓰지만 원본이 수정됨.반드시 실체가 있어야 하므로 nullptr 체크가 필요 없음.
- 장점
  - 성능 최적화(No Copy)
    참조는 주소만 넘기므로 데이터가 아무리 커도 속도가 동일함.
  - 다중 반환 효과
    C++ 함수는 return을 통해 하나의 값만 돌려줄 수 있음. 하지만 참조 매개변수를 여러 개 사용하면 함수 실행 결과로 여러 개의 값을 수정할 수 있음.
  - 다형성(Polymorphism) 유지
    상속 관계에 있는 클래스 객체를 함수에 넘길 때, 값으로 넘기면 객체 잘림(Slicing) 현상이 발생하여 자식 클래스의 특징을 잃어버림. 참조(또는 포인터)로 넘겨야만 부모 타입으로 자식 객체를 온전히 다룰 수 있음.
- 단점
  - 함수 안에서 원본이 바뀔 수 있다는 사실이 호출부만 봐서는 명확히 드러나지 않을 수 있어 const &를 자주 씀.
  - 함수가 종료되면 별명은 남고 실제 값은 사라지는데 지역 변수를 참조로 반환할 경우 반환값이 사라진 메모리를 가리킬 수 있어 지역 변수를 참조로 반환하면 안됨.

```cpp
void changeReference(int &ref) {
    ref = 999; // 별명을 통해 원본 수정
}

int main() {
    int x = 10;
    changeReference(x); // 변수 그대로 넘김 (별명 붙이기)
    // x는 이제 999
}
```

| 구분          | 값(Value)              | 주소(Address)              | 참조(Reference)         |
| ------------- | ---------------------- | -------------------------- | ----------------------- |
| 매개변수 형태 | int a                  | int \*a                    | int &a                  |
| 함수 호출     | f(x)                   | f(&x)                      | f(x)                    |
| 원본 수정     | 불가능                 | 가능                       | 가능                    |
| 복사 비용     | 데이터 크기만큼        | 주소값만큼                 | 거의 없음               |
| 주요 용도     | 작은 데이터, 원본 보호 | 배열 전달, Optional한 인자 | 큰 객체 전달, 원본 수정 |

### 트레일링 반환 타입(Trailing Return Types)

C++11부터 도입된 기능으로, 함수 선언에서 반환 타입을 매개변수 리스트 뒤에 명시하는 방법. 특히 복잡한 반환 타입을 가질 때 유용하며, 함수 템플릿과 함께 자주 사용됨.

- 주요 목적
  - 반환 타입이 매개변수에 의존하는 경우
  - 복잡한 함수 포인터나 람다식 반환 타입을 명확히 할 때
  - 가독성(이름 정렬 등) 향상

```cpp
#include <iostream>

// 매개변수의 타입을 곱한 결과를 반환하는 템플릿
template <typename T, typename U>
auto combine(T a, U b) -> decltype(a + b) {
    return a + b;
}

int main() {
    auto result = combine(10, 5.5); // int + double = double
    std::cout << "결과: " << result << std::endl; // 15.5

    return 0;
}
```

### 인라인 함수

함수 코드를 호출 지점에 직접 복사해버리는 듯한 효과. 보통 함수를 호출하면 프로그램은 실행 지점을 옮겼다가 다시 돌아오는 과정을 거치는데, 인라인 함수는 이 과정을 생략함.

- 함수 호출을 위한 스택 프레임 생성, 매개변수 복사, 주소 점프 등의 과정이 생략됨.
- 함수가 아주 짧고 자주 호출괴는 경우(ex: 단순 값을 반환하는 getter), 성능 향상이 뚜렷함.
- 함수가 호출되면 호출될 수록 복사하는 횟수가 늘어남. (Code Bloat 현상)
- 함수가 너무 길면 오히려 CPU 캐시 효율이 떨어져 프로그램이 느려짐.
- inline은 개발자의 요청일 뿐 강제 사항이 아니라 정말 인라인으로 구현될 지는 컴파일러의 재량에 맡김. 반재로 inline을 안 써도 가벼운 함수라면 컴파일러의 재량 하에 inline으로 구현되기도 함.
- 호출 지점에 코드를 복사해야 하므로, 반드시 헤더 파일에 정의 되어 있어야 함. (일반 함수는 소스 파일)

```cpp
inline int square(int x) {
    return x * x;
}

int main() {
    int a = 5;
    int result = square(a);
    // 컴파일 시점에 int result = a * a; 로 변경됨.
}
```

### 함수 오버로딩 (Function Overloading)

이름은 같지만 매개변수의 타입이나 개수가 다른 여러 개의 함수를 정의할 수 있게 해주는 기능.

- 성립 조건: 매개변수의 개수, 타입, 순서가 다를 때
- 반환 타입만 다르게 작성하는 것은 오버로딩이 안됨.
- 네임 맹글링(Name Mangling)으로 인해 가능한 상황.
  같은 함수 이름을 써도 컴파일러는 내부적으로 이름을 다르게 바꿔서 관리함. print(int) → \_print_int, print(double) → \_print_double처럼 고유한 이름을 붙이는 형식.
- 가독성과 편의성으로 인해 많이 사용됨.

### 기본 매개변수 (Default Parameters)

함수를 호출할 때 인자를 전달하지 않으면, 미리 설정해둔 기본값을 사용하도록 하는 기능.

- 매개변수 목록의 **오른쪽**부터 순차적으로 지정해야 함.
- 선언부와 정의부가 나뉠 경우 선언부(헤더 파일)에만 명시 → 선언부와 정의부 각각 다른 기본값을 가질 수 있어 에러 발생 가능성 있는 것을 방지.
- 함수 오버로딩 횟수를 줄여 코드가 간결해진다는 장점이 있음.
- 오버로딩과 혼용 시 컴파일러가 호출 대상을 못 찾는 'ambiguous' 에러 발생 주의.

```cpp
// .h 파일 (선언)
void display(int count = 1);
```

```cpp
// .cpp 파일 (정의)
void display(int count) {
    for(int i = 0; i < count; i++) cout << "*";
}
```

### 함수 포인터 (Function Pointers)

함수가 저장된 메모리 주소를 가리키는 포인터. 함수의 시작 주소를 저장했다가 필요할 때 그 주소로 찾아가 함수를 실행함.

- 선언: 반환타입 (\*포인터 이름)(매개변수 타입들);
- 로직의 추상화 상태로, 함수를 데이터처럼 주고 받을 수 있음.
- 함수 포인터를 선언할 때는 가리키고자 하는 함수의 반환 타입과 매개변수 타입이 완벽히 일치해야 함.

  ```cpp
  int add(int a, int b) { return a + b; }

  int main() {
      // 1. 함수 포인터 선언
      int (*fptr)(int, int);

      // 2. 함수의 주소를 대입 (함수 이름 자체가 주소)
      fptr = add;

      // 3. 포인터를 이용해 함수 호출
      int result = fptr(10, 20); // (*fptr)(10, 20) 도 가능하지만 보통 생략함
  }
  ```

- 주로 콜백(Callback)함수를 구현하기 위해 사용.

  ```cpp
  bool isEven(int n) { return n % 2 == 0; }
  bool isPositive(int n) { return n > 0; }

  // 함수 포인터를 매개변수로 받는 함수
  void printIf(int arr[], int size, bool (*condition)(int)) {
      for(int i = 0; i < size; i++) {
          if(condition(arr[i])) { // 넘겨받은 '조건' 함수를 실행
              cout << arr[i] << " ";
          }
      }
  }
  ```

- 함수 포인터는 가독성이 떨어지므로 typedef 또는 using 키워드를 사용하거나 <functional> 헤더에 들어있는 std::function을 쓰기도 함.

### 재귀 함수 호출 (Recursive Function Call)

자기 자신을 다시 호출하는 함수.

- 필수 조건
  - 기본 케이스 (Base Case): 재귀 호출을 멈추는 조건.
  - 재귀 단계 (Recursive Step): 문제를 더 작은 단위로 또개어 자기 자신을 호출하는 과정.

```cpp
void countDn(int n) {
    if (n <= 0) { // 기본 케이스
        return;
    }
    cout << n << " ";
    countDn(n - 1); // 재귀 단계
}
```

- 재귀 함수가 호출될 때마다 메모리 상에는 함수의 스택 프레임이 쌓임. 함수가 끝나기 전(return 전)에 또 함수를 호출하므로, 이전 함수의 메모리 공간은 그대로 남은 채 위에 새 공간이 생김. → 재귀가 너무 깊어지면 스택 오버플로우가 발생할 수 있으며 성능상 오버헤드(핵심 로직과는 상관 없지만 부가적으로 들어가는 시간이나 메모리)가 있음.
- 반복문으로 바꿀 수 있다면 성능을 위해 반복문을 쓰는 것이 일반 적임.
- 재귀 함수 디버깅 요령
  - **상향식(Bottom-up) 사고**: 가장 작은 단위(Base Case)가 무엇을 리턴하는지 먼저 확인.
  - **호출 순서**: 왼쪽 항을 먼저 완전히 해결하고 오른쪽으로 넘어감.
  - **중복 계산 확인**: 피보나치 재귀처럼 동일한 인자로 함수가 여러 번 호출된다면 비효율적인 코드일 가능성이 높음.

### 명령줄 인수 (Command Line Arguments)

프로그램을 실행할 때 터미널(CMD)에서 프로그램 이름 뒤에 추가로 전달하는 데이터.

```cpp
int main(int argc, char* argv[]) {
    // 로직
}
```

- argc (Argument Count): 전달된 인수의 개수. (정수)
- argv (Argument Vector): 실제 인수들의 내용을 담고 있는 문자열 배열. (포인터 배열)
- 첫 번째 인수는 프로그램 경로(argv[0])
- 모든 데이터는 문자열로 인식 되기 때문에 숫자로 계산하려면 std::stoi()나 atoi() 같은 함수로 변환해야 함.
- 반드시 argc를 먼저 검사하여 인덱스 참조 에러를 방지해야 함. (방어적 프로그래밍)

### 가변 인자 함수 (Ellipsis, '...')

매개변수의 개수가 정해지지 않은 함수를 정의할 때 사용. 보통 함수의 매개변수는 타입과 개수가 정해져 있으나 printf 같은 함수처럼 상황에 따라 인자의 개수가 제한될 수 없는 상황에 생략 부호를 사용.

- 주의 사항
  - 컴파일러가 인자의 타입을 검사하지 않음. 컴파일 시점에서는 알 수 없고 실행할 때 터짐.
  - 스스로 인자가 몇 개인지 알지 못함.
  - 기본 자료형이 아닌 복잡한 객체를 넘기면 예기치 동작이 발생할 수 있음.

- 현대 C++ 개발자들은 가변 인자 템플릿 (Variadic Templates)을 더 많이 사용. (컴파일 타임에 타입을 완벽히 체크함.)
- 같은 타입의 인자 여러 개를 받을 때 편리한 std::initializer_list를 사용하기도 함.
