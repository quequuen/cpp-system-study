## 포인터(Pointer)

메모리 주소를 저장하는 변수.

### 포인터 기조

- &(Address-of): 변수의 주소를 알아냄.
- \*(Dereference): 주소에 저장된 실제 값을 가져옴.
- 선언: 자료형\* 이름;

```cpp
int number = 7;
int* ptr = &number; // ptr에 number의 주소를 저장

cout << ptr;  // 주소값 출력 (예: 0x16fa3e7e8)
cout << *ptr; // 주소로 찾아가서 7을 출력
```

### void\*

포인터 변수의 크기는 가리키는 대상의 타입이 아니라 시스템의 비트 수에 따라 결정됨. void\*는 타입 정보를 제거하고 주소만 보관하는 **범용 바구니**.

```cpp
#include <iostream>

int main()
{
    using namespace std;
    // void a;
    // void는 메모리를 차지하지 않기 때문에 선언 불가

    char a = 'a';
    int b = 123;

    void *myvoid;
    // 이건 포인터를 사용하여 주소를 받기 때문에 선언 가능

    myvoid = (void*)&a;
    myvoid = (void*)&b;


    // cout << *myvoid << endl;
    cout << *(int*)myvoid;

    return 0;
}
```

- 주소값의 크기는 데이터 타입에 상관없이 모두 동일함.
- 일반 포인터를 void\*에 넣을 때는 명시적 캐스팅이 필수는 아님.(자동으로 형변환) → 그럼에도 사용하는 경우, **① 명시적인 의도 표현 (Readability)**: "내가 지금 이 주소를 타입 정보가 없는 상태로 다루겠다"라는 의미를 확실히 하기 위함, **② C언어와의 호환성 및 엄격한 규칙**: "내가 알고 하는 거니까 경고 띄우지마"라고 일부 엄격한 컴파일러 설정이나 특정 환경에게 알림.
- void\*의 치명적인 약점: void\*는 주소를 담을 수는 있지만, **그 주소에 가서 값을 읽어오는 것**은 불가능. 컴퓨터가 주소지에 도착했는데, 거기서 몇 바이트를 읽어야 할지(char면 1, int면 4)모르기 때문임. → 다시 값을 읽으려면 반드시 원래 타입으로 다시 형변환 해야 함.
