## 포인터(Pointer)

메모리 주소를 저장하는 변수. 주소를 담는 변수라서 실제 데이터 값을 담을 수는 없음.

### 포인터 기조

- &(Address-of): 변수의 주소를 알아냄.
- \*(Dereference): 주소에 저장된 실제 값을 가져옴.
- 선언: 자료형 \*이름;
- 포인터는 기본적으로 주소를 저장하는 것이기 때문에 크기가 정해져 있지만 어떤 타입의 데이터의 주소를 저장하는지 알기 위해 자료형을 붙여줌.
- 초기화가 안된 상태에서(쓰레기 값이 들어있는 상태)에서는 런타임 오류 발생.(보안의 문제가 발생할 수 있음)

```cpp
int number = 7;
int *ptr = &number; // ptr에 number의 주소를 저장

cout << ptr;  // 주소값 출력 (예: 0x16fa3e7e8)
cout << &ptr; // 주소값을 담은 포인터 변수의 주소 출력
cout << *ptr; // 주소로 찾아가서 7을 출력
```

### void\*

포인터 변수의 크기는 가리키는 대상의 타입이 아니라 시스템의 비트 수에 따라 결정됨. void\*는 타입 정보를 제거하고 주소만 보관하는 **범용 바구니**.

```cpp
#include <iostream>

int main()
{
    using namespace std;
    // void a;
    // void는 메모리를 차지하지 않기 때문에 선언 불가

    char a = 'a';
    int b = 123;

    void *myvoid;
    // 이건 포인터를 사용하여 주소를 받기 때문에 선언 가능

    myvoid = (void*)&a;
    myvoid = (void*)&b;


    // cout << *myvoid << endl;
    cout << *(int*)myvoid;

    return 0;
}
```

- 주소값의 크기는 데이터 타입에 상관없이 모두 동일함.
- 일반 포인터를 void\*에 넣을 때는 명시적 캐스팅이 필수는 아님.(자동으로 형변환) → 그럼에도 사용하는 경우, **① 명시적인 의도 표현 (Readability)**: "내가 지금 이 주소를 타입 정보가 없는 상태로 다루겠다"라는 의미를 확실히 하기 위함, **② C언어와의 호환성 및 엄격한 규칙**: "내가 알고 하는 거니까 경고 띄우지마"라고 일부 엄격한 컴파일러 설정이나 특정 환경에게 알림.
- void\*의 치명적인 약점: void\*는 주소를 담을 수는 있지만, **그 주소에 가서 값을 읽어오는 것**은 불가능. 컴퓨터가 주소지에 도착했는데, 거기서 몇 바이트를 읽어야 할지(char면 1, int면 4)모르기 때문임. → 다시 값을 읽으려면 반드시 원래 타입으로 다시 형변환 해야 함.

### 널 포인터(Null Pointers)

아무것도 가리키고 있지 않은 포인터. 포인터 변수를 선언할 때 바로 주소를 할당할 수 없다면, 일단 nullptr로 초기화하는 것이 철칙.

- 초기화를 하지 않은 포인터 변수는 쓰레기 주소값이 들어가 프로그램이 어디로 튈지 모르는 'Dangling Pointer' 문제가 발생할 수 있음.
- NULL이나 0은 포인터 타입이 아니기 때문에 오버로딩 될 시, 문제가 될 수 있어 NULL 값을 갖는 포인터, nullptr을 사용.
- nullptr은 말그대로 주소가 없는 것을 의미하므로 해당 변수의 내용을 보려고 하면(\*ptr) 프로그램은 즉시 런타임 에러를 내며 죽음.
- 그렇기 때문에 해당 변수를 역참조 하기 전, 확인이 필수임.
- #include <cstddef>에는 nullptr만 받아야 하는 파라미터인 std::nullptr_t가 존재.

```cpp
int* ptr = nullptr;

// 어떤 조건에 따라 주소를 할당

if (ptr) { // ptr != nullptr 와 같은 뜻
    cout << "주소로 찾아가 값을 읽습니다: " << *ptr << endl;
} else {
    cout << "현재 가리키는 대상이 없습니다." << endl;
}
```

### 배열과 포인터의 관계(Pointer Arithmetic)

배열의 이름은 사실 배열의 첫 번째 요소를 가리키는 포인터와 같음. 이러한 특성 때문에 함수의 인자로 전달되는 배열은 배열 그 자체가 아닌 포인터로 전달되기도 함. 또, 포인터에 숫자를 더하거나 빼서 배열 요소에 접근이 가능한데 이를 **포인터 산술 연산**이라고 함.

- 포인터 산술 연산

  ```cpp
  int arr[3] = {10, 20, 30};
  int* ptr = arr; // arr은 &arr[0]과 같음

  cout << "첫 번째: " << *ptr << endl;       // 10
  cout << "두 번째: " << *(ptr + 1) << endl; // 20
  cout << "세 번째: " << *(ptr + 2) << endl; // 30
  ```

  - 컴파일러는 ptr이 int\*라는 것을 알고 있음. 그래서 +1을 하면 다음 요소가 저장된 칸으로 가라는 것으로 해석해서 자동으로 타입의 크기(sizeof(int))만큼 주소를 점프시킴.
  - 기본 배열이 arr[i] 이런 식으로 요소에 접근하는 것도 실제로는 내부적으로 이렇게 작동함.

### 포인터와 문자열(char 배열)

`\0` (종단 문자)를 만날 때까지 포인터를 전진시키며 역참조(`*`)로 값을 읽는다.

```cpp
char str[] = "Hello, blank!";

// *ptr != '\0'은 문자열의 끝이 아닐 때까지 루프를 돌라는 뜻
for (char* ptr = str; *ptr != '\0'; ++ptr) {
    cout << *ptr; // 현재 가리키는 주소의 글자를 출력
}
```

- ++ptr을 하면 포인터가 다음 char주소(1바이트 뒤)로 점프함.

### 문자열 리터럴 포인터 (Symbolic Constant)

메모리에 고정된 문자열을 포인터로 가리키는 방식.

| 구분           | 배열(char str[])       | 심볼릭 상수(const char \*str)        |
| -------------- | ---------------------- | ------------------------------------ |
| 메모리 위치    | 스택 (Stack) 영역      | 상수/데이터 영역 (ReadOnly)          |
| 수정 가능 여부 | 가능 (str[0] = 'X')    | 불가능 (런타임 에러 발생 가능)       |
| 복사 여부      | 값을 스택으로 복사해옴 | 복사없이 원본의 주소만 가리킴        |
| 장점           | 자유로운 수정          | 메모리 절약 (같은 문자열은 재사용됨) |

- const char \*str = "문자열";
- **문자열 풀링 (String Pooling)**: 심볼릭 상수가 같은 내용의 문자열을 담으면 똑같은 주소를 가리키게 됨.

  ```cpp
      const char *name = "Hange Zoe";
      const char *same_name = "Hange Zoe";
      const char *diff_name = "Levi Ackerman";

      cout << (uintptr_t)name << endl;
      cout << (uintptr_t)same_name << endl;
      // 같은 값을 가진 두 변수는 같은 주소를 가짐
      cout << (uintptr_t)diff_name << endl;
      // 다른 값을 가진 diff_name은 다른 주소를 가짐
  ```

### 메모리 동적 할당 (Dynamic Memory Allocation)

필요한 만큼만 메모리를 빌려 쓰고, 다 쓰면 돌려주는 개념.
new와 delete라는 키워드를 사용하며, 이 메모리는 힙(Heap) 영역에 저장됨.

- new: 메모리 빌려오기(할당)
  프로그램이 실행되는 도중에 메모리를 요청함.

  ```cpp
    int* ptr = new int;      // int 하나 크기(4바이트)를 힙에 할당
    int* ptr2 = new int{10}; // 할당과 동시에 10으로 초기화
    int* arr = new int[5];   // int 5개짜리 배열을 힙에 할당
  ```

  - 할당된 메모리의 시작 주소를 반환하기 때문에 반드시 포인터 변수로 받아야 함.

- delete: 메모리 돌려주기(해제)
  빌린 메모리를 다 썼다면 반드시 운영체제에 돌려줘야 함.

  ```cpp
    delete ptr;       // 단일 객체 해제
    delete[] arr;     // 배열 형태의 메모리 해제
  ```

- 메모리 누수(Memory Leak)
  메모리를 빌려놓고, 반환하지 않은 상태에서 그 주소를 일어버리는 것.

  ```cpp
    void leakFunction()
    {
        int* temp = new int{50};
        // delete temp; // new로 할당은 했지만 delete를 안할 경우
    }
    // temp라는 포인터 변수는 사라졌지만, 힙에 할당된 50은 여전히 남아있음.
  ```

  이런 현상이 반복되면 프로그램이 사용하는 메모리가 점점 늘어나다가 결국 시스템이 느려지거나 멈춤(Crash). 해당 상황을 방지하기 위해 nullptr 체크를 습관화 하는 것이 좋음.

  ```cpp
    delete ptr;
    ptr = nullptr;
  ```
