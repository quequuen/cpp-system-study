## 포인터(Pointer)

메모리 주소를 저장하는 변수. 주소를 담는 변수라서 실제 데이터 값을 담을 수는 없음.

### 포인터 기조

- &(Address-of): 변수의 주소를 알아냄.
- \*(Dereference): 주소에 저장된 실제 값을 가져옴.
- 선언: 자료형 \*이름;
- 포인터는 기본적으로 주소를 저장하는 것이기 때문에 크기가 정해져 있지만 어떤 타입의 데이터의 주소를 저장하는지 알기 위해 자료형을 붙여줌.
- 초기화가 안된 상태에서(쓰레기 값이 들어있는 상태)에서는 런타임 오류 발생.(보안의 문제가 발생할 수 있음)

```cpp
int number = 7;
int *ptr = &number; // ptr에 number의 주소를 저장

cout << ptr;  // 주소값 출력 (예: 0x16fa3e7e8)
cout << &ptr; // 주소값을 담은 포인터 변수의 주소 출력
cout << *ptr; // 주소로 찾아가서 7을 출력
```

### void\*

포인터 변수의 크기는 가리키는 대상의 타입이 아니라 시스템의 비트 수에 따라 결정됨. void\*는 타입 정보를 제거하고 주소만 보관하는 **범용 바구니**.

```cpp
#include <iostream>

int main()
{
    using namespace std;
    // void a;
    // void는 메모리를 차지하지 않기 때문에 선언 불가

    char a = 'a';
    int b = 123;

    void *myvoid;
    // 이건 포인터를 사용하여 주소를 받기 때문에 선언 가능

    myvoid = (void*)&a;
    myvoid = (void*)&b;


    // cout << *myvoid << endl;
    cout << *(int*)myvoid;

    return 0;
}
```

- 주소값의 크기는 데이터 타입에 상관없이 모두 동일함.
- 일반 포인터를 void\*에 넣을 때는 명시적 캐스팅이 필수는 아님.(자동으로 형변환) → 그럼에도 사용하는 경우, **① 명시적인 의도 표현 (Readability)**: "내가 지금 이 주소를 타입 정보가 없는 상태로 다루겠다"라는 의미를 확실히 하기 위함, **② C언어와의 호환성 및 엄격한 규칙**: "내가 알고 하는 거니까 경고 띄우지마"라고 일부 엄격한 컴파일러 설정이나 특정 환경에게 알림.
- void\*의 치명적인 약점: void\*는 주소를 담을 수는 있지만, **그 주소에 가서 값을 읽어오는 것**은 불가능. 컴퓨터가 주소지에 도착했는데, 거기서 몇 바이트를 읽어야 할지(char면 1, int면 4)모르기 때문임. → 다시 값을 읽으려면 반드시 원래 타입으로 다시 형변환 해야 함.

### 널 포인터(Null Pointers)

아무것도 가리키고 있지 않은 포인터. 포인터 변수를 선언할 때 바로 주소를 할당할 수 없다면, 일단 nullptr로 초기화하는 것이 철칙.

- 초기화를 하지 않은 포인터 변수는 쓰레기 주소값이 들어가 프로그램이 어디로 튈지 모르는 'Dangling Pointer' 문제가 발생할 수 있음.
- NULL이나 0은 포인터 타입이 아니기 때문에 오버로딩 될 시, 문제가 될 수 있어 NULL 값을 갖는 포인터, nullptr을 사용.
- nullptr은 말그대로 주소가 없는 것을 의미하므로 해당 변수의 내용을 보려고 하면(\*ptr) 프로그램은 즉시 런타임 에러를 내며 죽음.
- 그렇기 때문에 해당 변수를 역참조 하기 전, 확인이 필수임.
- #include <cstddef>에는 nullptr만 받아야 하는 파라미터인 std::nullptr_t가 존재.

```cpp
int* ptr = nullptr;

// 어떤 조건에 따라 주소를 할당

if (ptr) { // ptr != nullptr 와 같은 뜻
    cout << "주소로 찾아가 값을 읽습니다: " << *ptr << endl;
} else {
    cout << "현재 가리키는 대상이 없습니다." << endl;
}
```

### 배열과 포인터의 관계(Pointer Arithmetic)

배열의 이름은 사실 배열의 첫 번째 요소를 가리키는 포인터와 같음. 이러한 특성 때문에 함수의 인자로 전달되는 배열은 배열 그 자체가 아닌 포인터로 전달되기도 함. 또, 포인터에 숫자를 더하거나 빼서 배열 요소에 접근이 가능한데 이를 **포인터 산술 연산**이라고 함.

- 포인터 산술 연산

  ```cpp
  int arr[3] = {10, 20, 30};
  int* ptr = arr; // arr은 &arr[0]과 같음

  cout << "첫 번째: " << *ptr << endl;       // 10
  cout << "두 번째: " << *(ptr + 1) << endl; // 20
  cout << "세 번째: " << *(ptr + 2) << endl; // 30
  ```

  - 컴파일러는 ptr이 int\*라는 것을 알고 있음. 그래서 +1을 하면 다음 요소가 저장된 칸으로 가라는 것으로 해석해서 자동으로 타입의 크기(sizeof(int))만큼 주소를 점프시킴.
  - 기본 배열이 arr[i] 이런 식으로 요소에 접근하는 것도 실제로는 내부적으로 이렇게 작동함.

### 포인터와 문자열(char 배열)

`\0` (종단 문자)를 만날 때까지 포인터를 전진시키며 역참조(`*`)로 값을 읽는다.

```cpp
char str[] = "Hello, blank!";

// *ptr != '\0'은 문자열의 끝이 아닐 때까지 루프를 돌라는 뜻
for (char* ptr = str; *ptr != '\0'; ++ptr) {
    cout << *ptr; // 현재 가리키는 주소의 글자를 출력
}
```

- ++ptr을 하면 포인터가 다음 char주소(1바이트 뒤)로 점프함.

### 문자열 리터럴 포인터 (Symbolic Constant)

메모리에 고정된 문자열을 포인터로 가리키는 방식.

| 구분           | 배열(char str[])       | 심볼릭 상수(const char \*str)        |
| -------------- | ---------------------- | ------------------------------------ |
| 메모리 위치    | 스택 (Stack) 영역      | 상수/데이터 영역 (ReadOnly)          |
| 수정 가능 여부 | 가능 (str[0] = 'X')    | 불가능 (런타임 에러 발생 가능)       |
| 복사 여부      | 값을 스택으로 복사해옴 | 복사없이 원본의 주소만 가리킴        |
| 장점           | 자유로운 수정          | 메모리 절약 (같은 문자열은 재사용됨) |

- const char \*str = "문자열";
- **문자열 풀링 (String Pooling)**: 심볼릭 상수가 같은 내용의 문자열을 담으면 똑같은 주소를 가리키게 됨.

  ```cpp
      const char *name = "Hange Zoe";
      const char *same_name = "Hange Zoe";
      const char *diff_name = "Levi Ackerman";

      cout << (uintptr_t)name << endl;
      cout << (uintptr_t)same_name << endl;
      // 같은 값을 가진 두 변수는 같은 주소를 가짐
      cout << (uintptr_t)diff_name << endl;
      // 다른 값을 가진 diff_name은 다른 주소를 가짐
  ```

### 메모리 동적 할당 (Dynamic Memory Allocation)

필요한 만큼만 메모리를 빌려 쓰고, 다 쓰면 돌려주는 개념.
new와 delete라는 키워드를 사용하며, 이 메모리는 힙(Heap) 영역에 저장됨.

- new: 메모리 빌려오기(할당)
  프로그램이 실행되는 도중에 메모리를 요청함.

  ```cpp
    int* ptr = new int;      // int 하나 크기(4바이트)를 힙에 할당
    int* ptr2 = new int{10}; // 할당과 동시에 10으로 초기화
    int* arr = new int[5];   // int 5개짜리 배열을 힙에 할당
  ```

  - 할당된 메모리의 시작 주소를 반환하기 때문에 반드시 포인터 변수로 받아야 함.

- delete: 메모리 돌려주기(해제)
  빌린 메모리를 다 썼다면 반드시 운영체제에 돌려줘야 함.

  ```cpp
    delete ptr;       // 단일 객체 해제
    delete[] arr;     // 배열 형태의 메모리 해제
  ```

- 메모리 누수(Memory Leak)
  메모리를 빌려놓고, 반환하지 않은 상태에서 그 주소를 일어버리는 것.

  ```cpp
    void leakFunction()
    {
        int* temp = new int{50};
        // delete temp; // new로 할당은 했지만 delete를 안할 경우
    }
    // temp라는 포인터 변수는 사라졌지만, 힙에 할당된 50은 여전히 남아있음.
  ```

  이런 현상이 반복되면 프로그램이 사용하는 메모리가 점점 늘어나다가 결국 시스템이 느려지거나 멈춤(Crash). 해당 상황을 방지하기 위해 nullptr 체크를 습관화 하는 것이 좋음.

  ```cpp
    delete ptr;
    ptr = nullptr;
  ```

### 동적 할당 배열 (Dynamically Allocating Arrays)

프로그램 실행 중에 사용자가 입력한 크기에 맞춰 메모리를 확보할 수 있음. 일반 배열은 반드시 상수로 크기를 정해야 하지만, 동적 배열은 변수로 크기를 정할 수 있음.

```cpp
int size;
cout << "배열 크기를 입력하세요: ";
cin >> size;

// 할당: heap 영역에 size만큼의 공간을 확보하고 첫 번째 주소를 반환
int* arr = new int[size];

// 사용: 일반 배열과 똑같이 사용 가능 (arr[i] == *(arr + i))
for (int i = 0; i < size; i++) {
    arr[i] = i + 1;
}

// 해제: 반드시 []를 붙여야 배열 전체가 올바르게 삭제됨
delete[] arr;
arr = nullptr; // 안전을 위한 널 포인터 처리
```

- 기존 배열의 크기 조절 (Resize)
  이미 할당된 동적 배열의 크기를 바로 늘리거나 줄이는 방법은 없음. 메모리는 연속된 공간이어야 하는데, 기존 배열 바로 뒤에 빈 공간이 있다는 보장이 없기 때문.
  그래서 Resize는 4단계를 거치며 구현.
  1. 새로운 크기의 배열을 힙에 새로 만듦.
  2. 기존 배열의 값을 새 배열로 복사.
  3. 기존 배열을 메모리에서 해제(delete[]).
  4. 포인터 변수가 변수가 새 배열의 주소를 가리키도록 업데이트.

  ```cpp
    int size = 5;
    int *arr = new int[size] {1, 2, 3, 4, 5};

    // Resize 시작: 크기 5 → 10
    int newSize = 10;
    // 1. 새 배열 생성
    int *newArr = new int[newSize];

    for (int i = 0; i < size; i++) {
        // 2. 기존 값 복사
        newArr[i] = arr[i];
    }

    // 3. 예집 부수기 (기존 메모리 해제)
    delete[] arr;
    // 4. 새집으로 명의 변경 (주소 업데이트)
    arr = newArr;
    size = newSize;
  ```

- 현대 배열의 크기 조절은 std::vector를 사용함.

```cpp
    #include <vector>
    vector<int> v = {1, 2, 3};
    v.push_back(4); // 자동 resize 후 4 추가
```

### 포인터와 const의 조합

- const T\* prt : **데이터** 보호(값 수정 불가).
- T\* const ptr : **주소** 보호(가리키는 대상 변경 불가).
- const T\* const ptr : **둘 다** 보호(읽기 전용).
- \*를 기준으로 const가 왼쪽에 있으면 **내용물**이 상수, 오른쪽에 있으면 **포인터 변수**가 상수.
- 함수 인자로 큰 데이터를 넘길 때 '복사는 안 하겠지만(포인터), 내용은 절대 안 건드릴게(const)'라는 약속으로 쓰이는 경우가 많음.

### 참조 변수 (Reference Variables)

기존 변수에 붙이는 별명(Alias).

- &를 붙여 선언 및 사용.
- 선언과 동시에 초기화: "누구의 별명인지" 처음ㅇ부터 정해야 함.
- 변경 불가능: 한 번 누구의 별명이 되면, 중간에 다른 변수의 별명으로 수정 불가능.
- NULL 불가: 참조자는 항상 실제 존재하는 변수만 가리켜야 함.(nullptr 같은 개념이 없음)
- 리터럴 사용 불가(리터럴은 주소를 가지지 않는 값을 대입하는 방식이기 때문).

| 특징        | 포인터(\*)           | 참조(&)                       |
| ----------- | -------------------- | ----------------------------- |
| 의미        | 주소를 저장하는 변수 | 변수에 붙은 별명              |
| 초기화      | 필수가 아님(위험)    | 필수                          |
| 재할당      | 가능                 | 불가능                        |
| 역참조 연산 | \*ptr 필요           | 없음(일반 변수처럼 사용 가능) |

### 참조와 const

강력한 데이터 보호 장치로 사용. 복사 비용을 없애면서(효율) 원본 수정은 막고 싶을 때(보안) 사용.

- 데이터를 복사하지 않고 주소만 넘기기 때문에 아주 빠른 속도로 큰 데이터를 다룰 수 있음.
- 인자로 넘길 시, 함수 내부에서 실수로 원본 데이터를 수정하는 위험을 문법적으로 막아줄 수 있음.
- 일반 참조 변수는 리터럴을 참조할 수 없지만 const를 붙이면 컴파일러가 임시 객체를 생성하여 수명을 연장.

```cpp
    int value = 10;
    const int &ref = value; // ref는 value의 별명이지만 '읽기 전용'

    // ref = 20;    // 컴파일 에러 발생 (별명을 통해서는 수정 불가)
    value = 20;     // 가능 (원본 자체를 바꾸는 건 당연히 가능)
    cout << ref;    // 20 출력 (원본이 바뀌면 별명으로 봐도 바뀜)
```
