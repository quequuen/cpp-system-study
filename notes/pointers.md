## 포인터(Pointer)

메모리 주소를 저장하는 변수.

### 포인터 기조

- &(Address-of): 변수의 주소를 알아냄.
- \*(Dereference): 주소에 저장된 실제 값을 가져옴.
- 선언: 자료형 \*이름;
- 포인터는 기본적으로 주소를 저장하는 것이기 때문에 크기가 정해져 있지만 어떤 타입의 데이터의 주소를 저장하는지 알기 위해 자료형을 붙여줌.
- 초기화가 안된 상태에서(쓰레기 값이 들어있는 상태)에서는 런타임 오류 발생.(보안의 문제가 발생할 수 있음)

```cpp
int number = 7;
int *ptr = &number; // ptr에 number의 주소를 저장

cout << ptr;  // 주소값 출력 (예: 0x16fa3e7e8)
cout << *ptr; // 주소로 찾아가서 7을 출력
```

### void\*

포인터 변수의 크기는 가리키는 대상의 타입이 아니라 시스템의 비트 수에 따라 결정됨. void\*는 타입 정보를 제거하고 주소만 보관하는 **범용 바구니**.

```cpp
#include <iostream>

int main()
{
    using namespace std;
    // void a;
    // void는 메모리를 차지하지 않기 때문에 선언 불가

    char a = 'a';
    int b = 123;

    void *myvoid;
    // 이건 포인터를 사용하여 주소를 받기 때문에 선언 가능

    myvoid = (void*)&a;
    myvoid = (void*)&b;


    // cout << *myvoid << endl;
    cout << *(int*)myvoid;

    return 0;
}
```

- 주소값의 크기는 데이터 타입에 상관없이 모두 동일함.
- 일반 포인터를 void\*에 넣을 때는 명시적 캐스팅이 필수는 아님.(자동으로 형변환) → 그럼에도 사용하는 경우, **① 명시적인 의도 표현 (Readability)**: "내가 지금 이 주소를 타입 정보가 없는 상태로 다루겠다"라는 의미를 확실히 하기 위함, **② C언어와의 호환성 및 엄격한 규칙**: "내가 알고 하는 거니까 경고 띄우지마"라고 일부 엄격한 컴파일러 설정이나 특정 환경에게 알림.
- void\*의 치명적인 약점: void\*는 주소를 담을 수는 있지만, **그 주소에 가서 값을 읽어오는 것**은 불가능. 컴퓨터가 주소지에 도착했는데, 거기서 몇 바이트를 읽어야 할지(char면 1, int면 4)모르기 때문임. → 다시 값을 읽으려면 반드시 원래 타입으로 다시 형변환 해야 함.

### 널 포인터(Null Pointers)

아무것도 가리키고 있지 않은 포인터. 포인터 변수를 선언할 때 바로 주소를 할당할 수 없다면, 일단 nullptr로 초기화하는 것이 철칙.

- 초기화를 하지 않은 포인터 변수는 쓰레기 주소값이 들어가 프로그램이 어디로 튈지 모르는 'Dangling Pointer' 문제가 발생할 수 있음.
- NULL이나 0은 포인터 타입이 아니기 때문에 오버로딩 될 시, 문제가 될 수 있어 NULL 값을 갖는 포인터, nullptr을 사용.
- nullptr은 말그대로 주소가 없는 것을 의미하므로 해당 변수의 내용을 보려고 하면(\*ptr) 프로그램은 즉시 런타임 에러를 내며 죽음.
- 그렇기 때문에 해당 변수를 역참조 하기 전, 확인이 필수임.
- #include <cstddef>에는 nullptr만 받아야 하는 파라미터인 std::nullptr_t가 존재.

```cpp
int* ptr = nullptr;

// 어떤 조건에 따라 주소를 할당

if (ptr) { // ptr != nullptr 와 같은 뜻
    cout << "주소로 찾아가 값을 읽습니다: " << *ptr << endl;
} else {
    cout << "현재 가리키는 대상이 없습니다." << endl;
}
```
