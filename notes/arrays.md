## 배열 Arrays

같은 타입의 변수들을 메모리에 연속적으로 나열하여 하나의 이름으로 관리.

### 배열 기초

- 타입 이름[크기];
- 초기화

  ```cpp
  // 1. 선언만 하기 (쓰레기 값이 들어있을 수 있음)
  int scores[5];

  // 2. 선언과 동시에 초기화 (초기화 리스트)
  int arr[5] = {10, 20, 30, 40, 50};

  // 3. 크기를 생략하고 초기화 (컴파일러가 개수를 보고 크기를 결정)
  int nums[] = {1, 2, 3}; // 크기는 3이 됨

  // 4. 전부 0으로 초기화
  int zeros[10] = {0};
  ```

- 인덱스(Index)와 접근
  배열의 가장 중요한 규칙은 번호(인덱스)가 0부터 시작한다는 점.
  - 첫번째 요소: arr[0]
  - 마지막 요소: arr[크기 - 1]
- 연속된 메모리: 배열의 요소들은 메모리 상 연속되어 있음.(이 성질 때문에 포인터와 밀접하게 연결됨.)
- 고정 크기: 한 번 정해진 배열의 크기는 실행 중에 바꿀 수 없음.(std::vector를 사용해 크기를 변경할 수는 있음.)
- 같은 타입만 담을 수 있음.
- 인덱스 범위 초과 오류 존재(Out of Range): 크기를 초과하는 곳에 접근을 하려고 할 때 오류.
- 배열 전체를 한 번에 대입 불가: int a[3] = {1, 2, 3}; int b[3]; b = a; 같은 코드는 작동하지 않음. 루프(for문)를 사용해 하나씩 복사해야 함.
- 배열의 함수 전달(Array Decay)

  - 배열을 함수 인자로 전달하면 배열의 첫 번째 요소를 가리키는 **포인터**로 변환됨.
  - 따라서 함수 내부에서 배열 요소를 수정하면 main의 원본 배열도 수정됨.
  - 함수 내에서는 배열의 실제 크기를 sizeof로 구할 수 없으므로, 관례상 배열 크기를 따로 전달함.

  ```cpp
    void doSomething(int arr[], int size)
    {
        //...
    }
  ```

  - 함수 인자로 넘어온 배열의 주소를 출력하면 원본 배열의 주소와 다름(주소값을 저장하기 위해 함수 내에 생성된 별도의 포인터 변수 공간이기 때문, 집 주소를 적은 쪽지와 같은 개념).

### 배열과 반복문

- std::size 사용(현대 C++의 표준 방식)

  ```cpp
    #include <iostream>
    #include <iterator> // std::size를 위해 필요

    int main() {
    int arr[] = {1, 2, 3, 4, 5};

        // 가장 권장되는 현대적 방식
        for (int i = 0; i < std::size(arr); ++i) {
            std::cout << arr[i] << " ";
        }

    }
  ```

- 범위 기반 for문(Range-based for loop)
  인덱스 번호 자체가 필요한 게 아니라 배열의 값만 순서대로 쓰고 싶을 때 사용.

  ```cpp
    for (int value : arr) {
    std::cout << value << " "; // 배열의 처음부터 끝까지 알아서 순회함
  }
  ```

- std::array 사용
  객체 지향적으로 사이즈 사용 가능.

  ```cpp
    #include <array>

    std::array<int, 5> arr = {1, 2, 3, 4, 5};
    for (int i = 0; i < arr.size(); ++i) { // .size() 멤버 함수 제공
    std::cout << arr[i];
    }
  ```

- 범위 기반 for문을 가장 많이 사용하며 인덱스가 필요한 상황일 시, std::size를 가장 많이 사용한다.

### 정적 다차원 배열(Multi-dimensional Array)

배열의 배열, 표(table)이나 공간의 형태로 데이터를 관리하는 방식. 주로 2차원 구조가 많이 쓰임.

- 타입 이름[행][열];

  ```cpp
  // 선언과 동시에 초기화 (중괄호 중첩)
  int matrix[2][3] = {
      {1, 2, 3}, // 0행
      {4, 5, 6}  // 1행
  };

  // 평면적으로 초기화 (컴파일러가 행/열 크기에 맞춰 알아서 자름)
  int matrix2[2][3] = {1, 2, 3, 4, 5, 6};

  // 행 크기 생략 가능 (열 크기는 반드시 명시해야 함)
  int matrix3[][3] = {{1, 2, 3}, {4, 5, 6}};
  ```

- 다차원 배열은 행과 열이 있는 표로 생각하기 쉽지만, 실제 컴퓨터 메모리 상에서는 1열로 쭉 늘어선 직선 형태.
- 다차원 배열 순회

  ```cpp
  const int rows = 2;
  const int cols = 3;
  int arr[rows][cols] = {{1, 2, 3}, {4, 5, 6}};

  for (int r = 0; r < rows; ++r) {
      for (int c = 0; c < cols; ++c) {
          cout << arr[r][c] << " ";
      }
      cout << endl;
  }
  ```

- 함수 인자로 전달되는 다차원 배열
  배열 쇠퇴 때문에 첫 번째 차원의 크기는 생략 가능하지만, 두 번째 차원부터는 반드시 크기를 적어야 함.

  ```cpp
  // 첫 번째 [ ]는 포인터로 변하지만, [3]은 주소 계산을 위해 고정되어야 함
  void printMatrix(int mat[][3], int rows) {
    for (int r = 0; r < rows; ++r) {
        for (int c = 0; c < 3; ++c) {
            cout << mat[r][c] << " ";
        }
    }
  }
  ```

- **스택 오버플로(Stack Overflow)**: 정적 배열은 스택(Stack) 메모리를 사용하는데, 스택은 크기가 제한적이라 너무 큰 다차원 배열을 선언하면 프로그램이 터질 수 있음.
- 3차원 이상의 배열은 가독성이 떨어지므로 구조체나 클래스로 변환.
