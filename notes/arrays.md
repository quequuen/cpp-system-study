## 배열 Arrays

같은 타입의 변수들을 메모리에 연속적으로 나열하여 하나의 이름으로 관리.

### 배열 기초

- 타입 이름[크기];
- 초기화

  ```cpp
  // 1. 선언만 하기 (쓰레기 값이 들어있을 수 있음)
  int scores[5];

  // 2. 선언과 동시에 초기화 (초기화 리스트)
  int arr[5] = {10, 20, 30, 40, 50};

  // 3. 크기를 생략하고 초기화 (컴파일러가 개수를 보고 크기를 결정)
  int nums[] = {1, 2, 3}; // 크기는 3이 됨

  // 4. 전부 0으로 초기화
  int zeros[10] = {0};
  ```

- 인덱스(Index)와 접근
  배열의 가장 중요한 규칙은 번호(인덱스)가 0부터 시작한다는 점.
  - 첫번째 요소: arr[0]
  - 마지막 요소: arr[크기 - 1]
- 연속된 메모리: 배열의 요소들은 메모리 상 연속되어 있음.(이 성질 때문에 포인터와 밀접하게 연결됨.)
- 고정 크기: 한 번 정해진 배열의 크기는 실행 중에 바꿀 수 없음.(std::vector를 사용해 크기를 변경할 수는 있음.)
- 같은 타입만 담을 수 있음.
- 인덱스 범위 초과 오류 존재(Out of Range): 크기를 초과하는 곳에 접근을 하려고 할 때 오류.
- 배열 전체를 한 번에 대입 불가: int a[3] = {1, 2, 3}; int b[3]; b = a; 같은 코드는 작동하지 않음. 루프(for문)를 사용해 하나씩 복사해야 함.
- 배열의 함수 전달(Array Decay)
  - 배열을 함수 인자로 전달하면 배열의 첫 번째 요소를 가리키는 **포인터**로 변환됨.
  - 따라서 함수 내부에서 배열 요소를 수정하면 main의 원본 배열도 수정됨.
  - 함수 내에서는 배열의 실제 크기를 sizeof로 구할 수 없으므로, 관례상 배열 크기를 따로 전달함.

  ```cpp
    void doSomething(int arr[], int size)
    {
        //...
    }
  ```

  - 함수 인자로 넘어온 배열의 주소를 출력하면 원본 배열의 주소와 다름(주소값을 저장하기 위해 함수 내에 생성된 별도의 포인터 변수 공간이기 때문, 집 주소를 적은 쪽지와 같은 개념).

### 배열과 반복문

- std::size 사용(현대 C++의 표준 방식)

  ```cpp
    #include <iostream>
    #include <iterator> // std::size를 위해 필요

    int main() {
    int arr[] = {1, 2, 3, 4, 5};

        // 가장 권장되는 현대적 방식
        for (int i = 0; i < std::size(arr); ++i) {
            std::cout << arr[i] << " ";
        }

    }
  ```

- 범위 기반 for문(Range-based for loop)
  인덱스 번호 자체가 필요한 게 아니라 배열의 값만 순서대로 쓰고 싶을 때 사용.

  ```cpp
    for (int value : arr) {
    std::cout << value << " "; // 배열의 처음부터 끝까지 알아서 순회함
  }
  ```

- std::array 사용
  객체 지향적으로 사이즈 사용 가능.

  ```cpp
    #include <array>

    std::array<int, 5> arr = {1, 2, 3, 4, 5};
    for (int i = 0; i < arr.size(); ++i) { // .size() 멤버 함수 제공
    std::cout << arr[i];
    }
  ```

- 범위 기반 for문을 가장 많이 사용하며 인덱스가 필요한 상황일 시, std::size를 가장 많이 사용한다.

### 정적 다차원 배열(Multi-dimensional Array)

배열의 배열, 표(table)이나 공간의 형태로 데이터를 관리하는 방식. 주로 2차원 구조가 많이 쓰임.

- 타입 이름[행][열];

  ```cpp
  // 선언과 동시에 초기화 (중괄호 중첩)
  int matrix[2][3] = {
      {1, 2, 3}, // 0행
      {4, 5, 6}  // 1행
  };

  // 평면적으로 초기화 (컴파일러가 행/열 크기에 맞춰 알아서 자름)
  int matrix2[2][3] = {1, 2, 3, 4, 5, 6};

  // 행 크기 생략 가능 (열 크기는 반드시 명시해야 함)
  int matrix3[][3] = {{1, 2, 3}, {4, 5, 6}};
  ```

- 다차원 배열은 행과 열이 있는 표로 생각하기 쉽지만, 실제 컴퓨터 메모리 상에서는 1열로 쭉 늘어선 직선 형태.
- 다차원 배열 순회

  ```cpp
  const int rows = 2;
  const int cols = 3;
  int arr[rows][cols] = {{1, 2, 3}, {4, 5, 6}};

  for (int r = 0; r < rows; ++r) {
      for (int c = 0; c < cols; ++c) {
          cout << arr[r][c] << " ";
      }
      cout << endl;
  }
  ```

- 함수 인자로 전달되는 다차원 배열
  배열 쇠퇴 때문에 첫 번째 차원의 크기는 생략 가능하지만, 두 번째 차원부터는 반드시 크기를 적어야 함.

  ```cpp
  // 첫 번째 [ ]는 포인터로 변하지만, [3]은 주소 계산을 위해 고정되어야 함
  void printMatrix(int mat[][3], int rows) {
    for (int r = 0; r < rows; ++r) {
        for (int c = 0; c < 3; ++c) {
            cout << mat[r][c] << " ";
        }
    }
  }
  ```

- **스택 오버플로(Stack Overflow)**: 정적 배열은 스택(Stack) 메모리를 사용하는데, 스택은 크기가 제한적이라 너무 큰 다차원 배열을 선언하면 프로그램이 터질 수 있음.
- 3차원 이상의 배열은 가독성이 떨어지므로 구조체나 클래스로 변환.

### 문자열(C-style String) 배열

- C-style 문자열은 단순한 char 타입의 배열이지만, 일반 배열과는 다르게 **종단 문자(Null Terminator)**가 존재.

```cpp
char str[] = "Hello";
// 메모리에는 ['H']['e']['l']['l']['o']['\0'] 순으로 저장됨
```

- 배열이기 때문에 선언 후 나중에 문자열을 통째로 대입할 수 없음.

```cpp
char name[10];
// name = "Gemini"; // 에러: 배열은 대입 연산이 안 됨
strcpy(name, "Gemini"); // <cstring> 헤더의 함수
```

- sizeof(str): 배열이 차지하는 전체 메모리 크기(종단 문자 포함).
- strlen(str): 실제 문자의 개수(종단 문자 제외).
- std::string 객체에서 C-style 문자열(주소값)을 뽑아낼 때 사용하는 함수가 바로 **.c_str()**

```cpp
std::string cppStr = "Hello";
const char* cStr = cppStr.c_str(); // C 스타일 주소값 반환
```

### strcpy와 strcmp

C-style 문자열(char[])은 객체가 아닌 **메모리 덩어리**이기 때문에, 일반적인 대입 연산자(=)나 비교 연산자(==)사용 불가. 대신 <cstring> 헤더에서 제공하는 전용 함수들을 사용해야 함. 그 중 가장 대표적인 두 함수.

- strcpy(String Copy): 문자열 복사
  배열은 서언된 이후에 str = "Hello";와 같이 값을 통때로 넣을 수 없음. 이때 strcpy를 사용해야 함.
  - strcpy(dest, src);
  - 원본 문자열을 대상(목적지) 배열에 복사함. (종단 문자 \\0까지 포함)

  ```cpp
  #include <cstring>

  char src[] = "Hello";
  char dest[10];

  strcpy(dest, src); // src의 내용을 dest로 복사

  ```

- 주의 사항: dest의 크기가 src보다 작으면 **버퍼 오버플로우(Buffer Overflow)**가 발생하여 프로그램이 터지거나 보안 취약점이 생김. 그래서 현재는 더 안전한 strncpy나 strcpy_s 사용을 권장.

- strcmp(String Compare): 문자열 비교
  C-style 문자열에서 str1 == str2 라고 쓰면, 문자열의 내용이 아니라 두 배열이 위치한 '메모리 주소'를 비교하게 됨. 내용물을 비교하려면 strcmp를 써야 함.
  - int result = strcmp(str1, str2);
  - 결과값
    1. 0: 두 문자열이 완벽히 일치함.
    2. 양수: str1이 사전순으로 더 뒤에 있음.
    3. 음수: str2이 사전순으로 더 뒤에 있음.

  ```cpp
  char a[] = "apple";
  char b[] = "apple";

  if (strcmp(a, b) == 0) {
  // 내용이 같을 때 실행됨
  }
  ```

- 그 외
  - strlen(s): 문자열의 길이를 반환(\\0 제외).
  - strcat(dest, src): 문자열 이어붙이기.

### std::array

C 스타일 배열의 성능과 표준 라이브러리(STL) 컨테이너의 편의성을 합친 현대적인 배열 도구. 정적 배열을 대체할 때 사용.

- 스택(Srack) 메모리 사용 → 매우 빠름.
- 템플릿 인자로 크기를 넘기기 때문에 컴파일 타임에 크기가 결정되어야 함.
- 헤더: <array>

```cpp
std::array<int, 3> arr = {10, 20, 30};

cout << arr[0];      // 속도가 빠르지만 범위 체크 안 함
cout << arr.at(1);   // 범위를 벗어나면 예외를 던져줌
cout << arr.front(); // 첫 번째 원소 (arr[0])
cout << arr.back();  // 마지막 원소 (arr[arr.size() - 1])

arr.fill(0);         // 모든 원소를 0으로 초기화
```

```cpp
std::array<int, 4> fibo = {0, 1, 1, 2};

for (const auto &n : fibo) {
    cout << n << " ";
}

// 내부 데이터를 포인터로 넘겨야 할 때 (C 라이브러리와 호환)
int* p = fibo.data();
```

### std::vector

동적 배열 컨테이너. new, delete, resize 등을 알아서 처리.

- 객체 자체는 스택에 있을 수 있지만 실제 데이터는 힙에 저장.
- 데이터가 메모리상에 연속적으로 붙어있어 인덱스(`[]`) 접근이 매우 빨라짐.
- 함수가 끝나거나 벡터가 사라질 때 스스로 delete를 호출함.(메모리 자동 해제)
- 자신이 몇 개의 데이터를 가졌는지 스스로 기억.

```cpp
#include <vector>
#include <iostream>

std::vector<int> v; // 크기가 0인 상태로 시작
std::vector<int> v2 = {1, 2, 3}; // 초기값 지정
std::vector<int> v3(10, 0); // 0으로 초기화된 10개짜리 배열 생성

v.push_back(10); // 맨 뒤에 10 추가
v.push_back(20);

cout << v[0];    // 인덱스 접근 (범위 체크 안 함)
cout << v.at(1); // 인덱스 접근 (범위 체크함)

v.pop_back();    // 맨 뒤의 원소 제거
v.clear();       // 모든 원소 삭제
v.size();        // 현재 들어있는 원소 개수
```

- 내부 동작 원리
  벡터는 매번 push_back 할 때마다 메모리가 이동하게 되면 성능이 떨어지므로, **여유 공간(Capacity)**을 미리 확보함.
  - 여유가 있을 때: 맨 뒤 빈 칸에 데이터를 추가.
  - 여유가 없을 때(Full)
    1. 현재 공간보다 보통 1.5 ~ 2배 더 큰 공간을 찾음.
    2. 기존 데이터를 새 공간으로 복사(또는 이동)
    3. 이전 공간 해제(delete)
    4. 포인터가 새 공간을 가리킴.
- 이사가 일어날 때 포인터 무효화라는 문제가 발생함. 이전 공간을 해제하고 메모리 주소가 아예 바뀌어 버리기 때문에 기존에 해당 데이터를 가리키던 포인터나 참조자가 쓰레기 값이 될 수 있음. → 이때, 몇 개의 데이터가 들어갈 것인지 미리 알고 있다면, reserve()로 미리 공간을 확보할 수 있음.

```cpp
vector<int> v;
v.reserve(1000);
```
